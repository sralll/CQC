<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CQC Pathfinder</title>
    <style>
        body, html {
            margin: 0;
            overflow: hidden;
            background-color: gray;
        }

        .modal {
            position: fixed;
            z-index: 2;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgb(0,0,0); /* Black background */
            background-color: rgba(0,0,0,0.4); /* Fallback for browsers that don't support rgba */
            padding: 20px;
        }

        #modalP {
            display: none;
        }

        .modal-content {
            background-color: #fefefe;
            margin-left: 5%;
            margin-right: 10%;
            margin-top: 5%;
            padding: 20px;
            border: 1px solid #888;
            position: relative;	
        }

        .modal-content > div {
                display: flex;
                align-items: center; /* Vertically center the input and buttons */
                gap: 10px; /* Add some space between the input and the buttons */
        }

        #projectTableDiv {
            position: relative;
            padding: 5px;
            max-height: 800px;
            overflow: auto;
        }

        #fileTable {
            display: block;
            table-layout:fixed;
            width: 100%;
            position: relative;
            border-collapse: collapse;
            max-height: 800px;
            overflow: auto;
        }

        .tableHeadProjects {
            padding: 5px;
            text-align: left;
            border: none;
            border-bottom: 1px solid #000;
            position: sticky;
            top: 0;
            background-color: #f2f2f2;
        }

        .closeModal {
            position: absolute;
            top: 0px;
            right: 10px;
            font-size: 30px;
            font-weight: bold;
            cursor: pointer;
            color: #aaa;
        }

        .closeModal:hover,
        .closeModal:focus {
            color: black;
            text-decoration: none;
        }

        #gameCanvas {
            display: block;
            width: 60%;
            height: 800px;
            border: #000 1px solid;
            margin: 5% auto;
            margin-bottom: 20px;
        }

        thead tr th, thead tr td {
            height: 50px;  /* Set a fixed height */
            line-height: 50px; /* Centers text vertically */
            text-align: center;
        }

        table {
            font-family: Arial, sans-serif; /* Change to your desired font */
        }

        #answerWrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%; /* Make sure it's full width */
            height: 100%; /* Ensure it takes full available height */
        }

        #resultBox {
            font-size: 30px;
            font-weight: bold;
            text-align: center;
            height: 50px;
            background-color: transparent;
            font-family: Arial, Helvetica, sans-serif;
            line-height: 50px; /* Vertically center text */
            display: inline-block; /* Makes the background fit the text */
            padding: 0 10px; /* Optional: Add some padding to the left and right of the text */
            margin-bottom: 10px; /* Add some space between the result box and the next element */
            width: 58%;
        }

        #routeButtonContainer {
            text-align: center; /* Ensure the buttons inside this container are centered */
            margin-top: 10px; /* Margin above buttons */
        }

        #nextButtonContainer {
            text-align: center; /* Center the next button */
            margin-top: 20px; /* Add margin between the table and the next button */
            display: none;
        }

        #nextButton {
            font-size: 24px; /* Increase text size */
            padding: 15px 30px; /* Increase padding for larger button */
            border: none; /* Remove the border */
            border-radius: 2px; /* Optional: rounded corners */
            cursor: pointer; /* Change cursor to pointer on hover */
            transition: background-color 0.3s; /* Smooth transition for background color */
        }

        #nextButton:hover {
            background-color: #afafaf; /* Darker background on hover */
        }


    </style>
</head>
<body>
    <button onclick="openModal()">Auswählen</button>
    <button onclick="startGame()">Start</button>
    <button onclick="prevControl()">Prev</button>

    <canvas id="gameCanvas"></canvas>

    <div id="modalP" class="modal">
        <div id="modalcP" class="modal-content">
			<span id="closeProjects" class="closeModal">&times;</span>

			<div id="projectTableDiv">
				<table id="fileTable">
					<thead>
						<tr>
							<th class="tableHeadProjects">Projekt</th>
							<th class="tableHeadProjects">Posten</th>
							<th class="tableHeadProjects">Letzte Änderungen</th>
						</tr>
					</thead>
					
					<tbody id="tbody" class = "tbody">
						<!-- File list will be dynamically inserted here -->
					</tbody>
				</table>
			</div>
        </div>
    </div>
    <div id="answerWrapper">
        <div id="resultBox"></div>
        <div id="routeButtonContainer" style="text-align: center; margin-top: 10px;"></div>
        <div id="nextButtonContainer">
            <button id="nextButton" onclick="nextControl()">Weiter (Enter)</button>
        </div>
    </div>
    <script>
        let cqc = null;
        let image = new Image();
        const runSpeed = 4.75; //m/s
        let choiceMade = false;

        const rControl = 25;		//radius of control circle

        const routeColor = ["#FFFF00", "#00FFFF", "#FF00FF", "#0000FF"];
        let selectedIndex = null; // Store the last clicked index

        let lastPressTime = null; // Store the time of the last button press
        let timeDiff = null;

        const canvas = document.getElementById("gameCanvas");
        const ctx = canvas.getContext("2d");
        const modalP = document.getElementById("modalP");
        const modalcP = document.getElementById("modalcP");
        const closeModal = document.getElementById("closeProjects");

        function openModal() {
            modalP.style.display = "block";
            loadFileList();
        }

        closeModal.onclick = () => modalP.style.display = "none";

        function loadFileList() {
            fetch('/get-files')
                .then(response => response.json())
                .then(files => {
                    // Sort files by modified date (latest first)
                    files.sort((a, b) => new Date(b.modified) - new Date(a.modified));

                    // Get or create the tbody element
                    let tbody = fileTable.querySelector('tbody');
                    if (!tbody) {
                        tbody = document.createElement('tbody');  // Create tbody if it doesn't exist
                        fileTable.appendChild(tbody);  // Append tbody to table
                    }

                    // Clear the existing table rows (inside tbody)
                    tbody.innerHTML = '';

                    // Loop through each file and add a row
                    files.forEach(file => {
                        const row = document.createElement('tr');
                        row.classList.add('tableRowProjects');
                        
                        // File name without the extension
                        const fileNameCell = document.createElement('td');
                        fileNameCell.classList.add('tableCellProjects');
                        const fileNameWithoutExtension = file.filename.replace('.json', ''); // Remove the '.json' extension
                        const fileNameText = document.createElement('span');
                        fileNameText.textContent = fileNameWithoutExtension || 'Unknown'; // Display filename without extension
                        
                        // Add hover effect to the table cell (feedback)
                        fileNameCell.style.cursor = 'pointer';
                        fileNameCell.addEventListener('mouseenter', () => {
                            fileNameCell.style.backgroundColor = '#f0f0f0'; // Light gray background when hovering
                        });
                        fileNameCell.addEventListener('mouseleave', () => {
                            fileNameCell.style.backgroundColor = ''; // Reset background when not hovering
                        });

                        // Add click event to set filename in input field (entire cell)
                        fileNameCell.addEventListener('click', () => {
                            loadGameData(file.filename); // Call the loadFile function when clicked                        });
                        });
                        fileNameCell.appendChild(fileNameText);
                        row.appendChild(fileNameCell);

                        // Number of cP entries
                        const cpCountCell = document.createElement('td');
                        cpCountCell.classList.add('tableCellProjects');
                        const cpCount = file.cPCount; // Count the number of cP entries (if exists)
                        cpCountCell.textContent = cpCount; // Display the number of cP entries
                        cpCountCell.style.textAlign = 'center'; // Center the text
                        row.appendChild(cpCountCell);

                        // Last modified time
                        const lastModifiedCell = document.createElement('td');
                        lastModifiedCell.classList.add('tableCellProjects');
                        
                        // Format the date and time to dd.mm.yyyy HH:mm:ss
                        const formattedDate = new Date(file.modified);
                        const day = String(formattedDate.getDate()).padStart(2, '0');
                        const month = String(formattedDate.getMonth() + 1).padStart(2, '0');
                        const year = formattedDate.getFullYear();
                        const hours = String(formattedDate.getHours()).padStart(2, '0');
                        const minutes = String(formattedDate.getMinutes()).padStart(2, '0');
                        const seconds = String(formattedDate.getSeconds()).padStart(2, '0');

                        const formattedDateString = `${day}.${month}.${year} ${hours}:${minutes}:${seconds}`;

                        lastModifiedCell.textContent = formattedDateString; // Display the formatted date and time

                        row.appendChild(lastModifiedCell);

                        // Append row to tbody
                        tbody.appendChild(row);
                    });
                })
                .catch(error => {
                    console.error('Error loading file list:', error);
                    alert('Failed to load file list');
                });
        }

        function loadGameData(filename) {
            fetch(`/load-file/${filename}`)
                .then(response => response.json())
                .then(fileData => {
                    cqc = fileData;
                    image.src = cqc.mapFile;
                    modalP.style.display = 'none';
                    makePreview();
                })
                .catch(error => {
                    console.error("Error loading game data:", error);
                    alert("Failed to load game data");
                });
        }

        document.addEventListener("keydown", function(e) {
            if (modalP.style.display === 'block') {
                switch (e.keyCode) {
                    case 27: //esc
                        modalP.style.display = 'none';
                    break
                }
            }
        });

        document.addEventListener("keydown", function(event) {
            if (event.key === "Enter" && choiceMade == true) { // Check if the pressed key is Enter
                nextControl(); // Call the nextControl function
            }
        });

        // Also, make sure to close the modal when clicking outside of the modal content
        window.addEventListener('click', (event) => {
            if (event.target === modalP) {
                modalP.style.display = 'none';
            }
        });

        function makePreview() {
            // Get image dimensions
            const imgWidth = image.naturalWidth;
            const imgHeight = image.naturalHeight;

            // Get canvas dimensions
            const canvasWidth = canvas.clientWidth;
            const canvasHeight = canvas.clientHeight;
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // Calculate the scale factor to fit the image into the canvas
            const scale = Math.min(canvasWidth / imgWidth, canvasHeight / imgHeight);

            // Calculate new image dimensions
            const newWidth = imgWidth * scale;
            const newHeight = imgHeight * scale;

            // Clear canvas before drawing
            ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

            // Center the image in the canvas
            const offsetX = (canvasWidth - newWidth) / 2;
            const offsetY = (canvasHeight - newHeight) / 2;

            // Draw the scaled image centered
            ctx.drawImage(image, 0, 0, imgWidth, imgHeight, offsetX, offsetY, newWidth, newHeight);
        }

        function startGame() {
            ncP = 0;

            document.getElementById("resultBox").innerHTML = "Bereit?";
            document.getElementById("resultBox").style.color = "blue";
            document.getElementById("resultBox").style.backgroundColor = "white";
            document.getElementById("nextButtonContainer").style.display = "none";
            document.getElementById("routeButtonContainer").innerHTML = "";

            // Delay the recalculation by 1 second (1000ms)
            setTimeout(function() {
                calcTransform(ncP);
                draw(ncP);
                playTiming();
            }, 1000); // Delay of 1000 milliseconds
        }

        function nextControl() {
            if (ncP < (cqc.cP.length - 1)) {
                ncP++;
            }

            document.getElementById("resultBox").innerHTML = "Bereit?";
            document.getElementById("resultBox").style.color = "blue";
            document.getElementById("nextButtonContainer").style.display = "none";
            document.getElementById("routeButtonContainer").innerHTML = "";

            // Delay the recalculation by 1 second (1000ms)
            setTimeout(function() {
                calcTransform(ncP);
                draw(ncP);
                playTiming();
            }, 1000); // Delay of 1000 milliseconds
        }

        function prevControl() {
            if (ncP > 0) {
                ncP--;
            }
            calcTransform(ncP);
            draw(ncP);
        }

        function calcTransform(ncP) {
            // Calculate the midpoint between start and ziel
            const midX = (cqc.cP[ncP].start.x + cqc.cP[ncP].ziel.x) / 2;
            const midY = (cqc.cP[ncP].start.y + cqc.cP[ncP].ziel.y) / 2;

            // Target position (center of the canvas)
            const targetX = canvas.width / 2;
            const targetY = canvas.height / 2;

            // Compute angle (rotation)
            const dx = (cqc.cP[ncP].ziel.x - cqc.cP[ncP].start.x);
            const dy = (cqc.cP[ncP].ziel.y - cqc.cP[ncP].start.y);
            const angle = Math.atan2(dy, dx); // Radians
            const originalLength  = Math.sqrt(dx * dx + dy * dy);

            const targetLength = 600; // HARDCODED for now
            let scaleFactor = targetLength / originalLength *cqc.scale;

            if (scaleFactor > 1) { //limit scaling
                scaleFactor = 1;
            }

            const cosA = Math.cos(-angle - Math.PI / 2);
            const sinA = Math.sin(-angle - Math.PI / 2);

            ctx.setTransform(1, 0, 0, 1, 0, 0); // Identity matrix
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Set the transformation matrix
            ctx.setTransform(
                scaleFactor * cosA,
                scaleFactor * sinA,
                -scaleFactor * sinA,
                scaleFactor * cosA,
                targetX - (midX / cqc.scale) * scaleFactor * cosA + (midY / cqc.scale) * scaleFactor * sinA,
                targetY - (midX / cqc.scale) * scaleFactor * sinA - (midY / cqc.scale) * scaleFactor * cosA
            );

            /* Discrete method
            ctx.translate(targetX, targetY);
            ctx.rotate(-angle-Math.PI/2);
            ctx.scale(scaleFactor, scaleFactor);
            ctx.translate(-midX/cqc.scale, -midY/cqc.scale);
            */
        }

        function drawMap() {
            ctx.drawImage(image, 0, 0);
        }

        function drawCP(ncP) {
            ctx.beginPath();
            ctx.arc(cqc.cP[ncP].start.x/cqc.scale, cqc.cP[ncP].start.y/cqc.scale, rControl/cqc.scale, 0, 2 * Math.PI);
			ctx.strokeStyle = "rgb(160, 51, 240,0.8)";
            ctx.lineWidth = 5;
            ctx.stroke();

            ctx.beginPath(ncP);
            ctx.arc(cqc.cP[ncP].ziel.x/cqc.scale, cqc.cP[ncP].ziel.y/cqc.scale, rControl/cqc.scale, 0, 2 * Math.PI);
			ctx.strokeStyle = "rgb(160, 51, 240,0.8)";
            ctx.lineWidth = 5;
            ctx.stroke();

            const angleC = Math.atan2(cqc.cP[ncP].ziel.y - cqc.cP[ncP].start.y, cqc.cP[ncP].ziel.x - cqc.cP[ncP].start.x);
            const distC = Math.sqrt(
                Math.pow(cqc.cP[ncP].ziel.x - cqc.cP[ncP].start.x, 2) +
                Math.pow(cqc.cP[ncP].ziel.y - cqc.cP[ncP].start.y, 2)
            );
            if (distC > 2 * (rControl)) {
                ctx.beginPath();
                ctx.lineWidth =  5;
                ctx.strokeStyle = "rgb(160, 51, 240,0.8)";
                ctx.moveTo(cqc.cP[ncP].start.x/cqc.scale + Math.cos(angleC) * (rControl + 0)/cqc.scale,
                    cqc.cP[ncP].start.y/cqc.scale + Math.sin(angleC) * (rControl + 0)/cqc.scale);
                ctx.lineTo(cqc.cP[ncP].ziel.x/cqc.scale - Math.cos(angleC) * (rControl + 0)/cqc.scale,
                    cqc.cP[ncP].ziel.y/cqc.scale - Math.sin(angleC) * (rControl + 0)/cqc.scale);
				ctx.stroke();
            }
        }

        function drawRoutes()  {
            ctx.beginPath();

            cqc.cP[ncP].route.forEach((route, nR) => {
                ctx.beginPath(); // Start a new path for each route
                route.rP.forEach((point, idx) => {
                    if (idx === 0) {
                        ctx.moveTo(point.x / cqc.scale, point.y / cqc.scale);
                    } else {
                        ctx.lineTo(point.x / cqc.scale, point.y / cqc.scale);
                    }
                });
                ctx.strokeStyle = "white"; // Ensure we don't go out of bounds
                ctx.lineWidth = 6;
                ctx.stroke(); // Stroke once per route, not per point
            });

            const randomizedIndices = generateRandomizedIndices(cqc.cP[ncP].route);
            
            const colorPicker = reduceColors(cqc.cP[ncP].route.length);
            const routeButtonContainer = document.getElementById("routeButtonContainer"); // Ensure you have a div with this ID
            routeButtonContainer.innerHTML = ""; // Clear existing cells

            const table = document.createElement("table");
            table.style.width = "60%";
            table.style.tableLayout = "fixed";
            table.style.margin = "auto";
            table.style.borderCollapse = "collapse";
            const thead = document.createElement("thead");
            const headerRow = document.createElement("tr");

            choiceMade = false;

            // Draw routes in randomized order
            randomizedIndices.forEach((index, indexColor) => {
                const route = cqc.cP[ncP].route[index];
                
                // Begin a new path for each route
                ctx.beginPath();
                route.rP.forEach((point, idx) => {
                    if (idx === 0) {
                        ctx.moveTo(point.x / cqc.scale, point.y / cqc.scale);
                    } else {
                        ctx.lineTo(point.x / cqc.scale, point.y / cqc.scale);
                    }
                });

                // Set the color for the route based on randomized index
                ctx.strokeStyle = routeColor[colorPicker[indexColor]];
                ctx.lineWidth = 4;
                ctx.stroke(); // Stroke the route

                const routeCell = document.createElement("td");
                routeCell.style.border = "1px solid black";
                routeCell.style.backgroundColor = routeColor[colorPicker[indexColor]]; // Assign color
                routeCell.style.cursor = "pointer";

                routeCell.addEventListener("click", () => {
                    submitChoice(index, randomizedIndices, colorPicker);
                });

                headerRow.appendChild(routeCell);

            });
            thead.appendChild(headerRow);
            table.appendChild(thead);
            routeButtonContainer.appendChild(table);

            document.getElementById("resultBox").innerHTML = "";
            document.getElementById("nextButtonContainer").style.display = "none";

        }

        function reduceColors(length) {
            let indices = Array.from({ length: routeColor.length }, (_, i) => i);

            for (let i = 0; indices.length != cqc.cP[ncP].route.length; i++) {
                const j = Math.floor(Math.random() * (indices.length));
                indices.splice(j, 1);
            }

            return indices;
        }

        function generateRandomizedIndices(route) {
            // Create an array of indices from 0 to route.length - 1
            const indices = Array.from({ length: route.length }, (_, index) => index);

            // Shuffle the indices array using Fisher-Yates (Durstenfeld) algorithm
            for (let i = indices.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [indices[i], indices[j]] = [indices[j], indices[i]];  // Swap the elements
            }

            return indices;
        }

        function submitChoice(index, routeOrder, reducedColorMap) {
            if (choiceMade) {
                return; // Prevent multiple selections
            }
            const choiceTime = playTiming();

            selectedIndex = index;
            const table = document.querySelector("#routeButtonContainer table");
            // Update the header row with additional text
            const headerRow = table.querySelector("thead tr");

            if (headerRow) {
                headerRow.cells[routeOrder.indexOf(index)].textContent = `X`;
                headerRow.cells[routeOrder.indexOf(index)].style.fontWeight = "bold";
            }
            
            let tbody = table.querySelector("tbody");
            if (!tbody) {
                tbody = document.createElement("tbody");
                table.appendChild(tbody);
            }

            const newRow = document.createElement("tr");
            const shortestIndex = cqc.cP[ncP].route
                .map((route, i) => ({ index: i, length: route.length }))
                .reduce((shortest, curr) => (curr.length < shortest.length ? curr : shortest)).index;
            
            document.getElementById("resultBox").innerHTML = "";

            // Loop through all routes and display their .dist property
            routeOrder.forEach((routeIndex) => {
                const cell = document.createElement("td");
                const currentRouteLength = cqc.cP[ncP].route[routeIndex].length;
                const shortestRouteLength = cqc.cP[ncP].route[shortestIndex].length;

                if (routeIndex == shortestIndex) {
                    cell.style.backgroundColor = "green"; // Highlight the selected choice
                } else {
                    cell.textContent = `+${Math.round((currentRouteLength / shortestRouteLength - 1) * 100)}% (+${Math.round((currentRouteLength - shortestRouteLength)/runSpeed)}s)`;
                }

                cell.style.border = "1px solid black";
                cell.style.padding = "10px";
                cell.style.textAlign = "center";

                newRow.appendChild(cell);
            });

            // Declare result variables
            let resultText = "";
            let resultColor = "";

            if (index === shortestIndex) {
                resultText = `richtig! (${choiceTime.toFixed(2)}s)`;
                resultColor = "green";
            } else {
                // Get the length of the selected route
                const selectedRouteLength = cqc.cP[ncP].route[index].length;
                const shortestRouteLength = cqc.cP[ncP].route[shortestIndex].length;

                // Calculate percentage difference
                const percentageLonger = Math.round((selectedRouteLength / shortestRouteLength - 1) * 100);

                if (percentageLonger <= 5) {
                    resultText = `okay (${choiceTime.toFixed(2)}s)`;
                    resultColor = "#F4C430";  // Fixed color name
                } else if (percentageLonger <= 10) {
                    resultText = `nicht ideal (${choiceTime.toFixed(2)}s)`;
                    resultColor = "orange";
                } else {
                    resultText = `Ui! (${choiceTime.toFixed(2)}s)`;
                    resultColor = "red";
                }
            }

            // Now update the result box
            document.getElementById("resultBox").innerHTML = resultText;
            document.getElementById("resultBox").style.color = resultColor;
            document.getElementById("resultBox").style.backgroundColor = "white";
            document.getElementById("nextButtonContainer").style.display = "block";

            tbody.appendChild(newRow);
            choiceMade = true;
        }

        // Function to record time difference between presses
        function playTiming() {
            const currentTime = Date.now(); // Get the current timestamp
            if (lastPressTime !== null) {
                timeDiff = (currentTime - lastPressTime) / 1000; // Convert to seconds
            }
            lastPressTime = currentTime; // Update the last press time
            return timeDiff;
        }

        function draw(ncP) {
            drawMap(ncP);
            drawCP(ncP);
            drawRoutes(ncP);
        }

    </script>
</body>
</html>